<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: app/requestCore/core.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: app/requestCore/core.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module app/requestCore/core */
module.exports = {
	/**
	* Goes through the requests array to see if the ID exists in the array
	* @param {string} id - ID of the user
	* @param {object} requests - Request list object obtained from the KV store
	*/
	checkUniqueRequest: function (id, requests) {
		if (requests === undefined) {
			requests = [];
		}
		//return true only if there is no request with the given id found in the KV store
		for (let i = 0; i &lt; requests.length; i++) {
			if (requests[i].Key === id) {
				return false;
			}
		}
		return true;
	},
	/**
	* Find the userToHmi, hmiToCore, and brokerAddress prefixes from all user requests
	* @param {array} keys - Consul KVs in the request list
	*/
	parseAddressesFromUserRequests: function (keys) {
		var addresses = [];
		if (keys !== undefined) {
			for (let i = 0; i &lt; keys.length; i++) {
				let value = JSON.parse(keys[i].Value);
				addresses.push(value.userToHmiPrefix);
				addresses.push(value.hmiToCorePrefix);
				addresses.push(value.brokerAddressPrefix);
			}
		}
		return addresses;
	},
	/**
	* Generate a new string from a function input and make sure it's not in the blacklist
	* @param {array} blackList - Forbidden strings
	* @param {callback} generatorFunc - function to generate a string
	* @returns {string} - A unique string
	*/
	getUniqueString: function (blackList, generatorFunc) {
		//use generatorFunc to keep creating new strings until
		//there is one that isn't part of the blackList, and return it
		var str = generatorFunc();
		while (blackList.find(checkList)) {
			str = generatorFunc();
		}
		return str;
		function checkList (item) {
			return str === item;
		}
	},
	/**
	* Generate a unique port not in the blacklist given a range
	* Warning: may be slow
	* Computation time proportional to &lt;possibilityNumber> * &lt;blackList.length>
	* @param {number} lowerBound - The minimum the port number can be
	* @param {number} upperBound - The maximum the port number can be
	* @param {array} blackList - Forbidden numbers
	* @returns {number} - A unique number
	*/
	getUniquePort: function (lowerBound, upperBound, blackList) {
		var possibilityNumber = upperBound - lowerBound + 1;
		if (upperBound &lt; lowerBound) {
			throw "Upper bound is less than lower bound";
		}
		//when mass generating numbers like these, don't leave it up to probability to find a unique number
		//generate all possible numbers and remove elements based on the blacklist
		var possibilities = [];
		for (let i = lowerBound; i &lt;= upperBound; i++) {
			possibilities.push(i);
		}
		//remove blacklist numbers
		possibilities = possibilities.filter(function (num) {
			return blackList.indexOf(num) === -1;
		});
		if (possibilities.length === 0) {
			//no possible number can be made
			throw "No possible number can be created given the blacklist";
		}
		var randomIndex = Math.floor(Math.random()*possibilities.length);
		return possibilities[randomIndex];
	},
	/**
	* Extract TCP external port numbers from an array of keys
	* @param {array} keys - Consul KVs in the request list
	* @returns {array} - All the TCP ports used
	*/
	getTcpPortsFromUserRequests: function (keys) {
		var ports = [];
		if (keys !== undefined) {
			for (let i = 0; i &lt; keys.length; i++) {
				let value = JSON.parse(keys[i].Value);
				ports.push(value.tcpPortExternal);
			}
		}
		return ports;
	}
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-app_controller.html">app/controller</a></li><li><a href="module-app_controller-logic.html">app/controller-logic</a></li><li><a href="module-app_requestCore_core.html">app/requestCore/core</a></li><li><a href="module-app_requestCore_shell.html">app/requestCore/shell</a></li><li><a href="module-app_requestLogs_core.html">app/requestLogs/core</a></li><li><a href="module-app_requestLogs_shell.html">app/requestLogs/shell</a></li><li><a href="module-app_watches_core.html">app/watches/core</a></li><li><a href="module-app_watches_job_core.html">app/watches/job/core</a></li><li><a href="module-app_watches_job_shell.html">app/watches/job/shell</a></li><li><a href="module-app_watches_proxy_shell.html">app/watches/proxy/shell</a></li><li><a href="module-app_watches_shell.html">app/watches/shell</a></li></ul><h3>Classes</h3><ul><li><a href="AllocationData.html">AllocationData</a></li><li><a href="AwsHandler.html">AwsHandler</a></li><li><a href="ConnectionSocket.html">ConnectionSocket</a></li><li><a href="Context.html">Context</a></li><li><a href="HAProxyTemplate.html">HAProxyTemplate</a></li><li><a href="Listener.html">Listener</a></li><li><a href="SocketHandler.html">SocketHandler</a></li><li><a href="UserRequest.html">UserRequest</a></li><li><a href="WaitingList.html">WaitingList</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Mar 08 2017 10:04:35 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
